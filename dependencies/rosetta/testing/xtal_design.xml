<ROSETTASCRIPTS>

	<SCOREFXNS>
		<ScoreFunction name="2015" weights="ref2015">
			<Reweight scoretype="coordinate_constraint" weight="%%cst_value%%"/>
			<!-- <Reweight scoretype="res_type_constraint" weight="1"/> -->
		</ScoreFunction>
		<ScoreFunction name="2015_soft" weights="ref2015_soft">
			<Reweight scoretype="coordinate_constraint" weight="%%cst_value%%"/>
			<!-- <Reweight scoretype="res_type_constraint" weight="1"/> -->
		</ScoreFunction>
		# patched version of above, reduces weights by 0.5 as the symmetric score function created with MakeLatticeMover and MakeLayerMover arbitrarily doubles monomeric energy
		<ScoreFunction name="2015_nano" weights="ref2015" patch="%%sym_score_patch%%">
			<Reweight scoretype="coordinate_constraint" weight="%%cst_value%%"/>
		</ScoreFunction>
		<ScoreFunction name="2015_nano_soft" weights="ref2015_soft" patch="%%sym_score_patch%%">
			<Reweight scoretype="coordinate_constraint" weight="%%cst_value%%"/>
		</ScoreFunction>
		<ScoreFunction name="2015_no_pssm" weights="ref2015">
			<Reweight scoretype="coordinate_constraint" weight="%%cst_value%%"/>
		</ScoreFunction>
		<!-- <ScoreFunction name="2015_pure" weights="ref2015"/> -->
	</SCOREFXNS>

	<RESIDUE_SELECTORS>
		# used for selecting residues on one side of the interface from chain "A". all resnums are listed 23,54,65,90,etc... in the %%interface1%% variable
		<Index name="A_interface" resnums="%%interface1%%" error_on_out_of_bounds_index="1" reverse="0"/>
		# same, but for residues from chain "B"
		<Index name="B_interface" resnums="%%interface2%%" error_on_out_of_bounds_index="1" reverse="0"/>
		# combined group of all identified interface residues
		<Or name="tot_interface" selectors="A_interface,B_interface"/>
		# the negation of all interface residues
		<Not name="not_interface" selector="tot_interface"/>
		# select all residues lower than energy 10 invloved in sidechain hydrogen bonding
		<HBond name="hbond_residues" residue_selector="tot_interface" include_bb_bb="false" hbond_energy_cutoff="10" scorefxn="2015_nano"/>
	</RESIDUE_SELECTORS>

	<TASKOPERATIONS>
		# standard task operation to pull in commandline options
		<InitializeFromCommandline name="init"/>
		# restrict movement of any virtual residues made during symmetry protocol. don't think these are allowed to move unless degrees of freedom are modified, but safe option nonetheless
		<RestrictIdentities name="vrt" identities="XXX" prevent_repacking="1"/>
		# standard operation to restrict all residues to repacking
		<RestrictToRepacking name="rtr"/>
		# make a design restriction at the beggining of design to make all designable interface residues Gly. They will be modified afterwards by other permissable residues
		<DesignRestrictions name="interface_start"> <Action residue_selector="tot_interface" aas="G"/> </DesignRestrictions>
		# disable repacking of the interface only
		<OperateOnResidueSubset name="int_no_repack" selector="tot_interface"> <PreventRepackingRLT/> </OperateOnResidueSubset>
		# restrict the interface to repacking only, no design
		<OperateOnResidueSubset name="int_rtr" selector="tot_interface"> <RestrictToRepackingRLT/> </OperateOnResidueSubset>
		# disable repacking of all non-interface residues
		<OperateOnResidueSubset name="non_int_no_repack" selector="not_interface"> <PreventRepackingRLT/> </OperateOnResidueSubset>
		# restrict all non-interface residues to repacking only, no design
		<OperateOnResidueSubset name="non_int_rtr" selector="not_interface"> <RestrictToRepackingRLT/> </OperateOnResidueSubset>
			<!-- <OperateOnResidueSubset name="non_int1_no_repack" selector="not_interface1"> <PreventRepackingRLT/></OperateOnResidueSubset> -->
			<!-- <OperateOnResidueSubset name="non_int2_no_repack" selector="not_interface2"> <PreventRepackingRLT/></OperateOnResidueSubset> -->
			<!-- <OperateOnResidueSubset name="int_hbonds" selector="not_hbonds"> <RestrictToRepackingRLT/></OperateOnResidueSubset> -->
		# only use residues included in a %%pssm_file%%. options specify how to treat the pssm and which rotamers to include for design
		<SeqprofConsensus name="pssm_cutoff" filename="%%pssm_file%%" min_aa_probability="0" convert_scores_to_probabilities="0" probability_larger_than_current="0" keep_native="1"/>
		# only use residues around specified resnums for design and repacking. The shell indicates a distance at which the mover searches for resnum neighbors to operate on
		<DesignAround name="des_around1" design_shell="0.1" resnums="%%interface1%%" repack_shell="8.0"/>
		<DesignAround name="des_around2" design_shell="0.1" resnums="%%interface2%%" repack_shell="8.0"/>
		<DesignAround name="des_around_total" design_shell="0.1" resnums="%%interface1%%,%%interface2%%" repack_shell="8.0"/>
	</TASKOPERATIONS>

<SIMPLE_METRICS>
		# gather the residues involved in a residue selector
		<SelectedResiduesMetric name="M_int_hbonds_res_selector" custom_type="hbonds_res" rosetta_numbering="false" residue_selector="hbond_residues"/>
		# find the per residue energy of residues in a residue_selector
		<PerResidueEnergyMetric name="M_int_energy_per_res" custom_type="per" output_as_pdb_nums="false" residue_selector="tot_interface" use_native="false" scoretype="total_score" scorefxn="2015_nano"/> 
		<PerResidueSasaMetric name="M_sasa_per_res" custom_type="per" output_as_pdb_nums="false" residue_selector="tot_interface" mode="all_sasa"/>
		<PerResidueSasaMetric name="M_sasa_hydrophobic_per_res" custom_type="per" output_as_pdb_nums="false" residue_selector="tot_interface" mode="hydrophobic_sasa"/>
		<PerResidueSasaMetric name="M_sasa_polar_per_res" custom_type="per" output_as_pdb_nums="false" residue_selector="tot_interface" mode="polar_sasa"/>
		# summarize the energy metrics from above
		<ResidueSummaryMetric name="M_int_energy_total" custom_type="int_energy" metric="M_int_energy_per_res" action="sum"/>

		# calculate the interaction energy metric between residues in two selections. I believe this in only the two body components to understand the interface component of energy
		<InteractionEnergyMetric name="M_int_energy" custom_type="" force_rescore="false" residue_selector="A_interface" residue_selector2="B_interface" scorefxn="2015_nano"/> #used to specify certain score terms to calculate on. include_rama_prepro_and_proclose="false". JD2 reports options invalid "scoretypes_only="" scoretypes_skip="""
	</SIMPLE_METRICS>

	<MOVERS>
		# generates symmetry for the system in question using the pose size of %%dist%%
		<MakeLatticeMover name="make_lattice" contact_dist="%%dist%%"/>
		# extracts from the symmetric pose to the asymmetric unit
		<ExtractAsymmetricUnit name="extract_asu" keep_virtual="0"/>
		# move two folds on different sides of a jump. this instance has the jump between chain A and B and moves them apart the distance on the specified axis (not sure how the axis are defined)
		<RigidBodyTransMover name="translate_asu" jump="1" distance="100.0" x="0.0" y="0.0" z="0.0"/>
		<SavePoseMover name="save_nanohedra" restore_pose="0" reference_name="nanohedra"/>
		<SavePoseMover name="restore_nanohedra" restore_pose="1" reference_name="nanohedra"/>
		# set all interface residues to GLY, leave everything else untouched
        <SymPackRotamersMover name="start_int" scorefxn="2015_nano_soft" task_operations="init,vrt,interface_start,non_int_no_repack"/> 
        # repack shell around a design residue
		<SymPackRotamersMover name="soft_design_int" scorefxn="2015_nano_soft" task_operations="init,vrt,pssm_cutoff,des_around_total"/> 
		# repack shell around a design residue read_resfile
		<SymPackRotamersMover name="hard_design_int" scorefxn="2015_nano" task_operations="init,vrt,pssm_cutoff,des_around_total"/> 
		<MinMover name="hard_min" scorefxn="2015_nano" chi="1" bb="0" jump="0"/>
		# minimize backbones/sc at interface (design), minimize sc elsewhere (packing)
		<TaskAwareSymMinMover name="soft_min_design_int" scorefxn="2015_nano_soft" bb="1" chi="1" task_operations="init,vrt,non_int_rtr"/> 
		# minimize backbones/sc at interface, minimize sc elsewhere
		<TaskAwareSymMinMover name="hard_min_design_int" scorefxn="2015_nano" bb="1" chi="1" task_operations="init,vrt,non_int_rtr"/> 
		# sample all rotamers to find minimum
		<SymRotamerTrialsMover name="RTmin" scorefxn="2015_nano" task_operations="init,rtr"/>
		# add coordinate constraint to residues not at interface
		<AtomCoordinateCstMover name="add_coord_cst" coord_dev="1" bounded="0" native="0" task_operations="init,vrt,non_int_rtr,int_no_repack"/> 
			<FavorSequenceProfile name="fsp" pssm="%%pssm_file%%" scaling="none" scorefxns="2015_nano,2015_nano_soft" weight="1"/> 
		# process mertics that are defined in the SimpleMetrics header above
		<RunSimpleMetrics name="run_metrics_hydrophobic_sasa" metrics="M_sasa_hydrophobic_per_res" prefix="" suffix="_hydrophobic_complex" override="false"/> 
		<RunSimpleMetrics name="run_metrics_polar_sasa" metrics="M_sasa_polar_per_res" prefix="" suffix="_polar_complex" override="false"/> 
		<RunSimpleMetrics name="run_metrics_sasa" metrics="M_sasa_per_res" prefix="" suffix="_total_complex" override="false"/> 
		<RunSimpleMetrics name="run_metrics" metrics="M_int_hbonds_res_selector,M_int_energy" prefix="" suffix="" override="false"/> #M_sequence,M_hbond_count,M_sasa,M_sasa_per_res,M_sasa_hydrophobic_per_res,M_sasa_polar_per_res,M_sasa_summary_hydrophobic,M_sasa_summary_polar,M_sasa_summary_total,M_tot_int_energy,M_int_hbonds
		<RunSimpleMetrics name="run_metrics_complex" metrics="M_int_energy_per_res,M_int_energy_total" prefix="" suffix="_complex" override="false"/> 
			<!-- <RunSimpleMetrics name="run_metrics_asu" metrics="M_int_energy_asu_per_res,M_int_energy_total_asu" prefix="" suffix="_asu" override="false"/> -->
			<!-- <RunSimpleMetrics name="run_metrics_unbound_asu" metrics="M_int_energy_unbound_per_res,M_int_energy_total_unbound" prefix="" suffix="_unbound" override="false"/>  -->
		# the main protocol to loop over for interface design
		<ParsedProtocol name="design_block">
			<Add mover_name="soft_design_int"/>
			<Add mover_name="soft_min_design_int"/>
			<Add mover_name="soft_design_int"/>
			<Add mover_name="hard_min_design_int"/>
			<Add mover_name="hard_design_int"/>
			<Add mover_name="hard_min_design_int"/>
			<Add mover_name="hard_design_int"/>
			<Add mover_name="RTmin"/>
			<Add mover_name="RTmin"/>
			<Add mover_name="hard_min"/>
		</ParsedProtocol>
		<LoopOver name="design_loop_4" iterations="4" mover_name="design_block"/>
	</MOVERS>

	<FILTERS>
		# reports the time of the protocol
		<Time name="time"/>
		# Energy Filters
		# reprot on the energy of particular scorefunctions and poses
		<ScoreType name="full_stability" scorefxn="2015_nano" score_type="total_score" threshold="20000" confidence="1.0"/>
			<ScoreType name="no_pssm_stability" scorefxn="2015_no_pssm" score_type="total_score" threshold="10000" confidence="1.0"/>
			<ScoreType name="pssm_weight" scorefxn="2015_nano" score_type="res_type_constraint" threshold="100000" confidence="1.0"/>
		<ScoreType name="cst_weight" scorefxn="2015_nano" score_type="coordinate_constraint" threshold="100000" confidence="1.0"/>
		# find the score of the residues in residue_selector. not sure how this is different from the metric InteractionGraph. the values output are different though and may have different score terms
		<ScorePoseSegmentFromResidueSelectorFilter name="int_energy_context_asu" in_context="1" residue_selector="tot_interface" scorefxn="2015" confidence="1.0"/>
		<ScorePoseSegmentFromResidueSelectorFilter name="int_energy_context_unbound" in_context="1" residue_selector="tot_interface" scorefxn="2015" confidence="1.0"/>
		<ScorePoseSegmentFromResidueSelectorFilter name="int_energy_context_complex" in_context="1" residue_selector="tot_interface" scorefxn="2015_nano" confidence="1.0"/>
		## Interface Metric Filters
		# find the average degree of connectivity to residues surrounding specified residues
		<AverageDegree name="int_connectivity1" threshold="0" distance_threshold="10.0" task_operations="des_around1"/>
		<AverageDegree name="int_connectivity2" threshold="0" distance_threshold="10.0" task_operations="des_around2"/>
		<AverageDegree name="int_connectivity_total" threshold="0" distance_threshold="10.0" task_operations="des_around_total"/>
		# find the number of carbon carbon contacts with specified residues
		<AtomicContactCount name="contact_count" partition="none" task_operations="init,vrt,non_int_no_repack" distance="5.0"/>
		# find the shape complementarity between residues in an interface. report the median distance (or interface area, but this seems inaccurate) between the two
		<ShapeComplementarity name="int_sc" min_sc="0.1" min_interface="0" residue_selector1="A_interface" residue_selector2="B_interface" write_median_dist="1" max_median_dist="0"/> #Bug in max_median_dist turns it into minimum median distance. If this is fixed, make the max something like 100+ as we just want the distance, not to actually filter
		# find the solvent accessable surface area across an interface specified by a chain-chain jump. can be hydrophobic, polar or if not specified, the total SASA
		<Sasa name="int_area_asu_hydrophobic" threshold="100" hydrophobic="1" polar="0" jump="1"/>
		<Sasa name="int_area_asu_polar" threshold="100" hydrophobic="0" polar="1" jump="1"/>
		# find the solvent accessable surface area for a specific residue set specified by PackerPalette, can be hydrophobic, polar or total if not specified. this is for the ASU
		<TotalSasa name="int_area_all_asu_hydrophobic" threshold="100" hydrophobic="1" polar="0" task_operations="init,vrt,non_int_no_repack"/>
		<TotalSasa name="int_area_all_asu_polar" threshold="100" hydrophobic="0" polar="1" task_operations="init,vrt,non_int_no_repack"/>
		# this is for the nanohedra state to figure out the surface area of specific regions in the interface such as the extra ASU interface region
		<TotalSasa name="int_area_all_nano_hydrophobic" threshold="100" hydrophobic="1" polar="0" task_operations="init,vrt,non_int_no_repack"/>
		<TotalSasa name="int_area_all_nano_polar" threshold="100" hydrophobic="0" polar="1" task_operations="init,vrt,non_int_no_repack"/>
		# find the total number of unstaisfied hydrogen honds in the specified interface. will be called at specific poses to determine BUNS at different locations in interface
		<BuriedUnsatHbonds name="buns_nano" residue_selector="tot_interface" scorefxn="2015_nano" use_ddG_style="true" report_all_unsats="true" confidence="1.0" ignore_surface_res="true" jump_number="2"/> print_out_info_to_pdb="true" 
		<BuriedUnsatHbonds name="buns_nano_hpol" residue_selector="tot_interface" scorefxn="2015_nano" use_ddG_style="true" report_nonheavy_unsats="true" confidence="1.0" ignore_surface_res="true" jump_number="2"/>
		<BuriedUnsatHbonds name="buns_asu" residue_selector="tot_interface" scorefxn="2015" use_ddG_style="true" report_all_unsats="true" confidence="1.0" ignore_surface_res="true" jump_number="1"/> print_out_info_to_pdb="true" 
		<BuriedUnsatHbonds name="buns_asu_hpol" residue_selector="tot_interface" scorefxn="2015" use_ddG_style="true" report_nonheavy_unsats="true" confidence="1.0" ignore_surface_res="true" jump_number="1"/>
		# find the difference in the Ca position of all residues in the asu versus a reference pose specified by -in:file:native on the command line
		<Rmsd name="rmsd" symmetry="0" chains="AB" threshold="1.0" confidence="1.0"/>
		## Reporters: access filters that change upon Pose manipulation. Must be run in specified Pose environment!! Afterwards, the value will be output to score location
		#  ASUextraction
		<Report name="R_int_area_all_asu_hydrophobic"	filter="int_area_all_asu_hydrophobic"/>
		<Report name="R_int_area_all_asu_polar" 		filter="int_area_all_asu_polar"/>
		<Report name="R_buns_asu" 						filter="buns_asu"/>
		<Report name="R_buns_asu_hpol" 					filter="buns_asu_hpol"/>
		<Report name="R_int_energy_context_asu"			filter="int_energy_context_asu"/>
		<Report name="R_int_energy_context_unbound"		filter="int_energy_context_unbound"/>
		<Report name="R_rmsd" 							filter="rmsd"/>
		#  Nanohedra
		<Report name="R_full_stability" 				filter="full_stability"/>
			<Report name="R_pssm_weight" 					filter="pssm_weight"/>
			<Report name="R_no_pssm_stability" 				filter="no_pssm_stability"/>
		<Report name="R_cst_weight" 					filter="cst_weight"/>
		<Report name="R_int_energy_context_complex"		filter="int_energy_context_complex"/>
		<Report name="R_int_sc" 						filter="int_sc"/>
		<Report name="R_int_connectivity1" 				filter="int_connectivity1"/>
		<Report name="R_int_connectivity2" 				filter="int_connectivity2"/>
		<Report name="R_contact_count" 					filter="contact_count"/>
		<Report name="R_buns_nano" 						filter="buns_nano"/>
		<Report name="R_buns_nano_hpol" 				filter="buns_nano_hpol"/>
			<!-- <Report name="R_nano_res_specific_sasa_total" filter="nano_res_specific_sasa_total"/> -->
		<Report name="R_int_area_all_nano_hydrophobic" 	filter="int_area_all_nano_hydrophobic"/>
		<Report name="R_int_area_all_nano_polar" 		filter="int_area_all_nano_polar"/>

		<Report name="R_int_area_asu_hydrophobic" 		filter="int_area_asu_hydrophobic"/>
		<Report name="R_int_area_asu_polar" 			filter="int_area_asu_polar"/>
		## Calculators
		# for calculating the extra asu interface area (hydrophobic, polar, and total) (SASA based)
		<CalculatorFilter name="int_area_ex_asu_hydrophobic" equation="Hasu - Hnano" threshold="0">
      		<Var name="Hasu" filter="R_int_area_all_asu_hydrophobic"/>
      		<Var name="Hnano" filter="R_int_area_all_nano_hydrophobic"/>  value="Real"
      	</CalculatorFilter>
      	<Report name="R_int_area_ex_asu_hydrophobic" filter="int_area_ex_asu_hydrophobic"/>
      	<CalculatorFilter name="int_area_ex_asu_polar" equation="Pasu - Pnano" threshold="0">
      		<Var name="Pasu" filter="R_int_area_all_asu_polar"/>
      		<Var name="Pnano" filter="R_int_area_all_nano_polar"/>
      	</CalculatorFilter>
		<Report name="R_int_area_ex_asu_polar" filter="int_area_ex_asu_polar"/>
      	<CalculatorFilter name="int_area_ex_asu_total" equation="H + P" threshold="0">
      		<Var name="H" filter="R_int_area_ex_asu_hydrophobic"/>
      		<Var name="P" filter="R_int_area_ex_asu_polar"/>
      	</CalculatorFilter>
      	<Report name="R_int_area_ex_asu_total" filter="int_area_ex_asu_total"/>
      	# calculate the asu interface area (SASA based)
      	<CalculatorFilter name="int_area_asu_total" equation="H + P" threshold="0">
      		<Var name="H" filter="R_int_area_asu_hydrophobic"/>
      		<Var name="P" filter="R_int_area_asu_polar"/>
      	</CalculatorFilter>
		<Report name="R_int_area_asu_total" filter="int_area_asu_total"/>
      	# calculate the total interface area (SASA based)
		<CalculatorFilter name="int_area_hydrophobic" equation="h_asu + h_ex" threshold="0">
      		<Var name="h_asu" filter="R_int_area_asu_hydrophobic"/>
      		<Var name="h_ex" filter="R_int_area_ex_asu_hydrophobic"/>
      	</CalculatorFilter>
 		<Report name="R_int_area_hydrophobic" filter="int_area_hydrophobic"/>
     	<CalculatorFilter name="int_area_polar" equation="p_asu + p_ex" threshold="0">
      		<Var name="p_asu" filter="R_int_area_asu_polar"/>
      		<Var name="p_ex" filter="R_int_area_ex_asu_polar"/>
      	</CalculatorFilter>
		<Report name="R_int_area_polar" filter="int_area_polar"/>
      	<CalculatorFilter name="int_area_total" equation="A + E" threshold="0">
      		<Var name="A" filter="R_int_area_asu_total"/>
      		<Var name="E" filter="R_int_area_ex_asu_total"/>
      	</CalculatorFilter>
		<Report name="R_int_area_total" filter="int_area_total"/>
		# calculate the total number of BUNS
      	<CalculatorFilter name="buns_total" equation="n + nhpol + a + ahpol" threshold="0">
      		<Var name="n" filter="R_buns_nano"/>
      		<Var name="nhpol" filter="R_buns_nano_hpol"/>
      		<Var name="a" filter="R_buns_asu"/>
      		<Var name="ahpol" filter="R_buns_asu_hpol"/>
      	</CalculatorFilter>
		<Report name="R_buns_total" filter="buns_total"/>
	</FILTERS>

	<PROTOCOLS>
		<Add filter_name="time" report_at_end="false"/>
		<Add mover_name="add_coord_cst"/>
			<Add mover_name="fsp"/>
		<Add mover_name="make_lattice"/>
		<Add mover_name="start_int"/>
		<Add mover_name="design_loop_4"/>
		<Add mover_name="save_nanohedra"/>
		# All between need to be run in the ASU
		<Add mover_name="extract_asu"/>
			<!-- <Add filter_name="asu_int_total" report_at_end="false"/> -->
		<Add filter_name="R_int_area_asu_hydrophobic"/>
		<Add filter_name="R_int_area_asu_polar"/>
		<Add filter_name="R_buns_asu"/>
		<Add filter_name="R_buns_asu_hpol"/>
		<Add filter_name="R_int_energy_context_asu"/>
		<Add filter_name="R_rmsd"/>
		<Add mover_name="translate_asu"/>
		<Add filter_name="R_int_energy_context_unbound"/>
		<Add filter_name="R_int_connectivity1"/>
		<Add filter_name="R_int_connectivity2"/>
		## Nanohedra analysis ##
		<Add mover_name="restore_nanohedra"/>
		<Add filter_name="R_full_stability"/>
			<Add filter_name="R_no_pssm_stability"/>
			<Add filter_name="R_pssm_weight"/>
		<Add filter_name="R_cst_weight"/>
		<Add filter_name="R_int_energy_context_complex"/>
		<Add filter_name="R_int_sc"/>
		<Add filter_name="R_contact_count"/>
		<Add mover_name="run_metrics_hydrophobic_sasa"/>
		<Add mover_name="run_metrics_polar_sasa"/>
		<Add mover_name="run_metrics_sasa"/>
		<Add mover_name="run_metrics"/>
		<Add mover_name="run_metrics_complex"/>
		<Add filter_name="R_buns_nano"/>
		<Add filter_name="R_buns_nano_hpol"/>
			<!-- <Add filter_name="R_nano_all_int_sasa_total"/> -->
			<!-- <Add filter_name="R_int_area_all_nano_total"/> -->
		<Add filter_name="R_int_area_asu_total"/>
		<Add filter_name="R_int_area_ex_asu_hydrophobic"/>
		<Add filter_name="R_int_area_ex_asu_polar"/>
		<Add filter_name="R_int_area_ex_asu_total"/>
		<Add filter_name="R_int_area_hydrophobic"/>
		<Add filter_name="R_int_area_polar"/>
		<Add filter_name="R_int_area_total"/>
		<Add filter_name="R_buns_total"/>
		<Add filter_name="time"/>
	</PROTOCOLS>

</ROSETTASCRIPTS>
