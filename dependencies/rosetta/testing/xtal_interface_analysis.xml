<ROSETTASCRIPTS>

	<SCOREFXNS>
		# used for typical scoring applications. the base Rosetta energy function
		<ScoreFunction name="2015" weights="ref2015">
		</ScoreFunction>
		# used for soft minimization and design. the base Rosetta energy function with reduced lennard-jones full atom repulsive terms. good to avoid high clash score in early design to smooth the eneryg landscape
		<ScoreFunction name="2015_soft" weights="ref2015_soft">
		</ScoreFunction>
		# patched version of above. The patch file in %%sym_score_patch%% will reduce the weights by 0.5 as the symmetric score function created with MakeLatticeMover and MakeLayerMover arbitrarily double the monomeric energy. This is fine, but in order for comparision to the unsymmetric system, this reduction is necessary
		<ScoreFunction name="2015_nano" weights="ref2015" patch="%%sym_score_patch%%">
		</ScoreFunction>
		# soft variant of the patch
		<ScoreFunction name="2015_nano_soft" weights="ref2015_soft" patch="%%sym_score_patch%%">
		</ScoreFunction>
	</SCOREFXNS>

	<RESIDUE_SELECTORS>
		# used for selecting residues on one side of the interface from chain "A". all resnums are listed 23,54,65,90,etc... in the %%interface1%% variable
		<Index name="interface1" resnums="%%interface1%%" error_on_out_of_bounds_index="1" reverse="0"/>
		# same, but for residues from chain "B"
		<Index name="interface2" resnums="%%interface2%%" error_on_out_of_bounds_index="1" reverse="0"/>
		# combined group of all identified interface residues
		<Or name="tot_interface" selectors="interface1,interface2"/>
		# the negation of all interface residues
		<Not name="not_interface" selector="tot_interface"/>
		# select all residues lower than energy 10 invloved in sidechain hydrogen bonding
		<HBond name="hbond_residues" residue_selector="tot_interface" include_bb_bb="false" hbond_energy_cutoff="10" scorefxn="2015_nano"/>
		<!-- <Index name="asu_interface" resnums="%%asu_interface%%" error_on_out_of_bounds_index="1" reverse="0"/> -->
		<!-- <Index name="ex_asu_interface" resnums="%%ex_asu_interface%%" error_on_out_of_bounds_index="1" reverse="0"/> -->
			<!-- <Index name="tot_interface" resnums="%%interface1%%,%%interface2%%" error_on_out_of_bounds_index="1" reverse="0"/> -->
			<!-- <Not name="not_interface1" selector="interface1"/> -->
			<!-- <Not name="not_interface2" selector="interface2"/> -->
			<!-- <Not name="not_hbonds" selector="hbond_residues"/> -->
	</RESIDUE_SELECTORS>

	# restrict the PackerPalette
	<TASKOPERATIONS>
		# standard task operation to pull in commandline options
		<InitializeFromCommandline name="init"/>
		# restrict movement of any virtual residues made during symmetry protocol. don't think these are allowed to move unless degrees of freedom are modified, but safe option nonetheless
		<RestrictIdentities name="vrt" identities="XXX" prevent_repacking="1"/>
		# standard operation to restrict all residues to repacking
		<RestrictToRepacking name="rtr"/>
		# make a design restriction at the beggining of design to make all designable interface residues Gly. They will be modified afterwards by other permissable residues
		<DesignRestrictions name="interface_start"> <Action residue_selector="tot_interface" aas="G"/> </DesignRestrictions>
		# disable repacking of the interface only
		<OperateOnResidueSubset name="int_no_repack" selector="tot_interface"> <PreventRepackingRLT/> </OperateOnResidueSubset>
		# restrict the interface to repacking only, no design
		<OperateOnResidueSubset name="int_rtr" selector="tot_interface"> <RestrictToRepackingRLT/> </OperateOnResidueSubset>
		# disable repacking of all non-interface residues
		<OperateOnResidueSubset name="non_int_no_repack" selector="not_interface"> <PreventRepackingRLT/> </OperateOnResidueSubset>
		# restrict all non-interface residues to repacking only, no design
		<OperateOnResidueSubset name="non_int_rtr" selector="not_interface"> <RestrictToRepackingRLT/> </OperateOnResidueSubset>
			<!-- <OperateOnResidueSubset name="non_int1_no_repack" selector="not_interface1"> <PreventRepackingRLT/></OperateOnResidueSubset> -->
			<!-- <OperateOnResidueSubset name="non_int2_no_repack" selector="not_interface2"> <PreventRepackingRLT/></OperateOnResidueSubset> -->
			<!-- <OperateOnResidueSubset name="int_hbonds" selector="not_hbonds"> <RestrictToRepackingRLT/></OperateOnResidueSubset> -->
		# only use residues included in a %%pssm_file%%. options specify how to treat the pssm and which rotamers to include for design
		<SeqprofConsensus name="pssm_cutoff" filename="%%pssm_file%%" min_aa_probability="0" convert_scores_to_probabilities="0" probability_larger_than_current="0" keep_native="1"/>
		# only use residues around specified resnums for design and repacking. The shell indicates a distance at which the mover searches for resnum neighbors to operate on
		<DesignAround name="des_around1" design_shell="0.1" resnums="%%interface1%%" repack_shell="8.0"/>
		<DesignAround name="des_around2" design_shell="0.1" resnums="%%interface2%%" repack_shell="8.0"/>
		<DesignAround name="des_around_total" design_shell="0.1" resnums="%%interface1%%,%%interface2%%" repack_shell="8.0"/>
	</TASKOPERATIONS>

	# report on various pose metrics. will see greater development as currently filter produce most metrics, however, metrics don't always need to filter out design trajectories. only output to score/pdb if the metric is part of the pose upon successful program completion
	<SIMPLE_METRICS>
		# gather the sequence of a pose
			<!-- <SequenceMetric name="M_sequence" custom_type="" output_mode="oneletter"/> residue_selector="" -->
		# count of a specific residue selection in the current pose to score/pdb
			<!-- <SelectedResidueCountMetric name="M_hbond_count" custom_type="hbond_res" residue_selector="hbond_residues"/> -->
		# gather the residues involved in a residue selector
		<SelectedResiduesMetric name="M_int_hbonds_res_selector" custom_type="hbonds_res" rosetta_numbering="false" residue_selector="hbond_residues"/>
		# gather the SASA of a residue selection
			<!-- <SasaMetric name="M_sasa" custom_type="" residue_selector="tot_interface" sasa_metric_mode="all_sasa"/> -->
		# gather the per residue SASA of a residue selection
			<!-- <PerResidueSasaMetric name="M_sasa_per_res" custom_type="per" output_as_pdb_nums="false" residue_selector="tot_interface" mode="all_sasa"/> -->
		# gather the per residue SASA of a residue selection - hydrophobic
			<!-- <PerResidueSasaMetric name="M_sasa_hydrophobic_per_res" custom_type="hydrophobic_per" output_as_pdb_nums="false" residue_selector="tot_interface" mode="hydrophobic_sasa"/> --> #To Use need ASU and chain separated METRICS to compare to. This would find the change in SASA in complex versus alone and allow finer/residue analysis. May be possible with Rosetta Updates
		# gather the per residue SASA of a residue selection - polar
			<!-- <PerResidueSasaMetric name="M_sasa_polar_per_res" custom_type="polar_per" output_as_pdb_nums="false" residue_selector="tot_interface" mode="polar_sasa"/> -->
		# summarize the metric from a PerResidueMetric. This is for the total SASA from above
			<!-- <ResidueSummaryMetric name="M_sasa_summary_total" custom_type="int_sasa" metric="M_sasa_per_res" action="sum"/> epsilon=".0001" Action choices are: [mean, n_res_eq, n_res_gt, n_res_gt_or_eq, n_res_lt, n_res_lt_or_eq, n_res_ne, sum] if comparison use action_value="real" to specify the value use_cached_data="false" cache_prefix="" cache_suffix="" fail_on_missing_cache="true" -->
		# summarize the metric from a PerResidueMetric. This is for the hydrophobic SASA from above
			<!-- <ResidueSummaryMetric name="M_sasa_summary_hydrophobic" custom_type="int_hydrophbic_sasa" metric="M_sasa_hydrophobic_per_res" action="sum"/> --> #Redundant with filter below
		# summarize the metric from a PerResidueMetric. This is for the polar SASA from above
			<!-- <ResidueSummaryMetric name="M_sasa_summary_polar" custom_type="int_polar_sasa" metric="M_sasa_polar_per_res" action="sum"/> --> #Redundant with filter below
		# find the residues involved in hydrogen bonding. this metric seems to be broken when used with a residue_selector2 as of 4/1/20. other means towards this information are available
				<!-- <HbondMetric name="M_int_hbonds" custom_type="" output_as_pdb_nums="false" residue_selector="A_interface" residue_selector2="B_interface" include_self="false"/> JD2 reports residue_selector is invalid option-->
		# find the total energy for a residue selection
			<!-- <TotalEnergyMetric name="M_tot_int_energy" custom_type="" use_native="false" scoretype="total_score" residue_selector="tot_interface" scorefxn="2015_nano"/> reference_name="" -->
		# find the per residue energy of residues in a residue_selector. compares to a reference_name or to native or just raw values depending on options. when comparisons are made, the answer = the current pose - reference/native pose (found in a saved pose (Need SavePoseMover with correct name))
		<PerResidueEnergyMetric name="M_int_energy_per_res" custom_type="per" output_as_pdb_nums="false" residue_selector="tot_interface" use_native="false" scoretype="total_score" scorefxn="2015_nano"/> 
		<PerResidueEnergyMetric name="M_int_energy_asu_per_res" custom_type="per" output_as_pdb_nums="false" residue_selector="tot_interface" reference_name="asu" scoretype="total_score" scorefxn="2015_nano"/>
		<PerResidueEnergyMetric name="M_int_energy_unbound_per_res" custom_type="per" output_as_pdb_nums="false" residue_selector="tot_interface" reference_name="asu_unbound" scoretype="total_score" scorefxn="2015_nano"/> # use_native="false" is not valid option when using reference_name?
		# summarize the energy metrics from above
		<ResidueSummaryMetric name="M_int_energy_total" custom_type="int_energy" metric="M_int_energy_per_res" action="sum"/>
		<ResidueSummaryMetric name="M_int_energy_total_asu" custom_type="int_energy" metric="M_int_energy_asu_per_res" action="sum"/>
		<ResidueSummaryMetric name="M_int_energy_total_unbound" custom_type="int_energy" metric="M_int_energy_unbound_per_res" action="sum"/>
		# calculate the interaction energy metric between residues in two selections. I believe this in only the two body components to understand the interface component of energy
		<InteractionEnergyMetric name="M_int_energy" custom_type="" force_rescore="false" residue_selector="A_interface" residue_selector2="B_interface" scorefxn="2015_nano"/> #used to specify certain score terms to calculate on. include_rama_prepro_and_proclose="false". JD2 reports options invalid "scoretypes_only="" scoretypes_skip="""
	</SIMPLE_METRICS>

	<MOVERS>
		# generates symmetry for the system in question using the pose size of %%dist%%
		<MakeLatticeMover name="make_lattice" contact_dist="%%dist%%"/>
		# extracts from the symmetric pose to the asymmetric unit
		<ExtractAsymmetricUnit name="extract_asu" keep_virtual="0"/>
		# move two folds on different sides of a jump. this instance has the jump between chain A and B and moves them apart the distance on the specified axis (not sure how the axis are defined)
		<RigidBodyTransMover name="translate_asu" jump="1" distance="1000.0" x="0.0" y="0.0" z="0.0"/>
		# saves a intermediate pdb to disk in the directory where Rosetta was initiated
		<DumpPdb name="dump_pdb_unbound_asu" fname="asu_unbound_tx.pdb" scorefxn="2015" tag_time="0"/>
		# starts the relaxation protocol to minimize the structure given to Rosetta
		<FastRelax name="relax" scorefxn="2015" relaxscript="default"/>
		# process mertics that are defined in the SimpleMetrics header above
		M_int_hbonds_res_selector,,M_int_energy
		<RunSimpleMetrics name="run_metrics" metrics="M_int_hbonds_res_selector,M_int_energy" prefix="" suffix="" override="false"/> M_sequence,M_hbond_count,M_sasa,M_sasa_per_res,M_sasa_hydrophobic_per_res,M_sasa_polar_per_res,M_sasa_summary_hydrophobic,M_sasa_summary_polar,M_sasa_summary_total,M_tot_int_energy,M_int_hbonds
		<RunSimpleMetrics name="run_metrics_complex" metrics="M_int_energy_per_res,M_int_energy_total" prefix="" suffix="_complex" override="false"/> 
		<RunSimpleMetrics name="run_metrics_asu" metrics="M_int_energy_asu_per_res,M_int_energy_total_asu" prefix="" suffix="_asu" override="false"/>
		<RunSimpleMetrics name="run_metrics_unbound_asu" metrics="M_int_energy_unbound_per_res,M_int_energy_total_unbound" prefix="" suffix="_unbound" override="false"/> 
		# save the current pose to the cache so that it could be retrieved at a later point in the protocol
		<SavePoseMover name="save_nanohedra" restore_pose="0" reference_name="nanohedra"/> pdb_file="" 
		<SavePoseMover name="save_asu" restore_pose="0" reference_name="asu"/> pdb_file=""
		<SavePoseMover name="save_asu_unbound" restore_pose="0" reference_name="asu_unbound"/> pdb_file=""
		<SavePoseMover name="restore_nanohedra" restore_pose="1" reference_name="nanohedra"/> pdb_file="" 
		# analyze interfaces with a variety of metrics. Very useful, unfortunately not modular enough to run reliably for all design instances
			<!-- <InterfaceAnalyzerMover name="interface_analyzer_nano" scorefxn="2015_nano" pack_separated="false" pack_input="false" resfile="false" packstat="false" interface_sc="false" tracer="true" use_jobname="false" jump="1"/> scorefile_reporting_prefix="IA_" #fixedchains="(string)" interface="(string)" ligandchain="(string)" -->
			<!-- <InterfaceAnalyzerMover name="interface_analyzer_nano_fixed_AB" scorefxn="2015_nano" pack_separated="false" pack_input="false" resfile="false" packstat="false" interface_sc="false" tracer="true" use_jobname="false" fixedchains="A,B"/> jump="1" scorefile_reporting_prefix="IA_" interface="(string)" ligandchain="(string)" -->
			<!-- <InterfaceAnalyzerMover name="interface_analyzer_nano_fixed_A" scorefxn="2015_nano" pack_separated="false" pack_input="false" resfile="false" packstat="false" interface_sc="false" tracer="true" use_jobname="false" fixedchains="A"/> jump="1" scorefile_reporting_prefix="IA_" interface="(string)" ligandchain="(string)" -->
			<!-- <InterfaceAnalyzerMover name="interface_analyzer_asu" scorefxn="2015" pack_separated="false" pack_input="false" resfile="false" packstat="false" interface_sc="false" tracer="true" use_jobname="false" jump="1"/> scorefile_reporting_prefix="IA_" #fixedchains="(string)" interface="(string)" ligandchain="(string)" -->
	</MOVERS>

	# calculate some metric of the pose and compare to a threshold to see if the pose satisfies the threshold. always stores the metric in the pose and can report to scorefile/pdb after the run
	<FILTERS>
		# reports the time of the protocol. must be designated twice to "start" and "stop"
		<Time name="time"/>
		# Energy Filters
		# report on the energy of particular scorefunctions and poses
		<ScoreType name="full_stability" scorefxn="2015_nano" score_type="total_score" threshold="20000" confidence="1.0"/>
		<!-- <ScoreType name="no_pssm_stability" scorefxn="2015_no_pssm" score_type="total_score" threshold="10000" confidence="1.0"/> -->
		<ScoreType name="cst_weight" scorefxn="2015_nano" score_type="coordinate_constraint" threshold="100000" confidence="1.0"/>
		<ScoreType name="pssm_weight" scorefxn="2015_nano" score_type="res_type_constraint" threshold="100000" confidence="1.0"/>
		# find the score of the residues in residue_selector. not sure how this is different from the metric InteractionGraph. the values output are different though and may have different score terms
		<ScorePoseSegmentFromResidueSelectorFilter name="int_energy_context" in_context="1" residue_selector="tot_interface" scorefxn="2015_nano" confidence="1.0"/>
				<!-- <EnergyPerResidue name="energy_per_res" scorefxn="2015_nano" score_type="total_score" energy_cutoff="100.0" bb_bb="1" resnums="%%interface%%" whole_protein="0" whole_interface="0" jump_number="1" interface_distance_cutoff="8.0"/> # pdb_num/res_num="string" resn resns="'1'" -->
				<!-- <ScorePoseSegmentFromResidueSelectorFilter name="int_energy" in_context="0" residue_selector="tot_interface" scorefxn="2015_nano" confidence="0"/> -->
		# Interface Metric Filters
		# find the average degree of connectivity to residues surrounding specified residues
		<AverageDegree name="int_connectivity1" threshold="0" distance_threshold="10.0" task_operations="des_around1"/>
		<AverageDegree name="int_connectivity2" threshold="0" distance_threshold="10.0" task_operations="des_around2"/>
		<AverageDegree name="int_connectivity_total" threshold="0" distance_threshold="10.0" task_operations="des_around_total"/>
		# find the number of carbon carbon contacts with specified residues
		<AtomicContactCount name="contact_count" partition="none" task_operations="init,vrt,non_int_no_repack" distance="5.0"/>
		# find the shape complementarity between residues in an interface. report the median distance (or interface area, but this seems inaccurate) between the two
		<ShapeComplementarity name="int_sc" min_sc="0.1" min_interface="0" residue_selector1="A_interface" residue_selector2="B_interface" write_median_dist="1" max_median_dist="0"/> write_int_area="1". This area doesn't make sense in the light of SASA calculations #Bug in max_median_dist turns it into minimum median distance. If this is fixed, make the max something like 100+ as we just want the distance, not to actually filter
		# find the buried surface area of specified residues. reports the per residue burial in the tracer, but the full values to score/pdb output. Value is not super useful unless per residue info could be accessed
			<!-- <BuriedSurfaceArea name="bsa_total" filter_out_low="false" cutoff_buried_surface_area="100" atom_mode="all_atoms" residue_selector="tot_interface"/> -->
			<!-- <BuriedSurfaceArea name="bsa_hydrophobic" filter_out_low="false" cutoff_buried_surface_area="100" atom_mode="hydrophobic_atoms" residue_selector="tot_interface"/> -->
			<!-- <BuriedSurfaceArea name="bsa_polar" filter_out_low="false" cutoff_buried_surface_area="100" atom_mode="polar_atoms" residue_selector="tot_interface"/> -->
		# find the solvent accessable surface area across an interface specified by a chain-chain jump. can be hydrophobic, polar or if not specified, the total SASA
			<!-- <Sasa name="asu_int_total_area" threshold="100" hydrophobic="0" polar="0" jump="1"/> -->
		<Sasa name="int_area_asu_hydrophobic" threshold="100" hydrophobic="1" polar="0" jump="1"/>
		<Sasa name="int_area_asu_polar" threshold="100" hydrophobic="0" polar="1" jump="1"/>
		# find the solvent accessable surface area for a specific residue set specified by PackerPalette, can be hydrophobic, polar or total if not specified. this is for the ASU
			<!-- <TotalSasa name="asu_res_specific_sasa_total" threshold="100" hydrophobic="0" polar="0" task_operations="init,vrt,non_int_no_repack"/> -->
		<TotalSasa name="int_area_all_asu_hydrophobic" threshold="100" hydrophobic="1" polar="0" task_operations="init,vrt,non_int_no_repack"/>
		<TotalSasa name="int_area_all_asu_polar" threshold="100" hydrophobic="0" polar="1" task_operations="init,vrt,non_int_no_repack"/>
		# this is for the nanohedra state to figure out the surface area of specific regions in the interface such as the extra ASU interface region
			<!-- <TotalSasa name="nano_res_specific_sasa_total" threshold="100" hydrophobic="0" polar="0" task_operations="init,vrt,non_int_no_repack"/> -->
		<TotalSasa name="int_area_all_nano_hydrophobic" threshold="100" hydrophobic="1" polar="0" task_operations="init,vrt,non_int_no_repack"/>
		<TotalSasa name="int_area_all_nano_polar" threshold="100" hydrophobic="0" polar="1" task_operations="init,vrt,non_int_no_repack"/>
		# find the total number of unstaisfied hydrogen honds in the specified interface. will be called at specific poses to determine BUNS at different locations in interface
		<BuriedUnsatHbonds name="buns_nano" residue_selector="tot_interface" scorefxn="2015_nano" use_ddG_style="true" report_all_unsats="true" confidence="1.0" ignore_surface_res="true" jump_number="2"/> print_out_info_to_pdb="true" 
		<BuriedUnsatHbonds name="buns_nano_hpol" residue_selector="tot_interface" scorefxn="2015_nano" use_ddG_style="true" report_nonheavy_unsats="true" confidence="1.0" ignore_surface_res="true" jump_number="2"/>
		<BuriedUnsatHbonds name="buns_asu" residue_selector="tot_interface" scorefxn="2015" use_ddG_style="true" report_all_unsats="true" confidence="1.0" ignore_surface_res="true" jump_number="1"/> print_out_info_to_pdb="true" 
		<BuriedUnsatHbonds name="buns_asu_hpol" residue_selector="tot_interface" scorefxn="2015" use_ddG_style="true" report_nonheavy_unsats="true" confidence="1.0" ignore_surface_res="true" jump_number="1"/>
		# find the difference in the Ca position of all residues in the asu versus a reference pose specified by -in:file:native on the command line
		<Rmsd name="rmsd" symmetry="0" chains="AB" threshold="1.0" confidence="1.0"/>
				<!-- <SymUnsatHbonds name="sym_buried_unsat_int" jump="1" cutoff="20" verbose="true" write2pdb="true"/> -->
				<!-- <DesignableResidues name="hbond_report" task_operations="vrt,int_hbonds" designable="1" packable="0" lower_cutoff="0" upper_cutoff="10000"/> -->
				<!-- <HbondsToResidue name="hbonds_filter" scorefxn="2015_nano" energy_cutoff="10" backbone="true" bb_bb="true" sidechain="true" from_other_chains="true" from_same_chain="false" residue_selector="hbond_residues"/> partners="" residue="32 this argument is necessary" -->
		## For reporting above filters that change upon Pose manipulation. Must be run in specified Pose environment!! ##
		#  ASUextraction
		<Report name="R_int_area_all_asu_hydrophobic"	filter="int_area_all_asu_hydrophobic"/>
		<Report name="R_int_area_all_asu_polar" 		filter="int_area_all_asu_polar"/>
		<Report name="R_buns_asu" 						filter="buns_asu"/>
		<Report name="R_buns_asu_hpol" 					filter="buns_asu_hpol"/>
		<Report name="R_rmsd" 							filter="rmsd"/>
		#  Nanohedra
		<Report name="R_full_stability" 				filter="full_stability"/>
		<Report name="R_pssm_weight" 					filter="pssm_weight"/>
		<Report name="R_cst_weight" 					filter="cst_weight"/>
		<!-- <Report name="R_no_pssm_stability" filter="no_pssm_stability"/> -->
		<Report name="R_int_sc" 						filter="int_sc"/>
		<Report name="R_int_connectivity1" 				filter="int_connectivity1"/>
		<Report name="R_int_connectivity2" 				filter="int_connectivity2"/>
			<!-- <Report name="R_int_connectivity" 				filter="int_connectivity"/> -->
		<Report name="R_contact_count" 					filter="contact_count"/>
			<!-- <Report name="R_bsa_total" filter="bsa_total"/> -->
			<!-- <Report name="R_bsa_hydrophobic" 				filter="bsa_hydrophobic"/> -->
			<!-- <Report name="R_bsa_polar" 						filter="bsa_polar"/> -->
		
		<Report name="R_int_energy_context" 			filter="int_energy_context"/>
		<Report name="R_buns_nano" 						filter="buns_nano"/>
		<Report name="R_buns_nano_hpol" 				filter="buns_nano_hpol"/>
			<!-- <Report name="R_nano_res_specific_sasa_total" filter="nano_res_specific_sasa_total"/> -->
		<Report name="R_int_area_all_nano_hydrophobic" 	filter="int_area_all_nano_hydrophobic"/>
		<Report name="R_int_area_all_nano_polar" 		filter="int_area_all_nano_polar"/>

		<Report name="R_int_area_asu_hydrophobic" 		filter="int_area_asu_hydrophobic"/>
		<Report name="R_int_area_asu_polar" 			filter="int_area_asu_polar"/>
				<!-- <Report name="R_hbond_report" filter="hbond_report"/> -->
			<!-- <Report name="R_energy_per_res" 				filter="energy_per_res"/> -->
				<!-- <Report name="R_hbonds_filter" filter="hbonds_filter"/> -->
		#  Calculators
		# for calculating the extra asu interface area (hydrophobic, polar, and total) (SASA based)
		<CalculatorFilter name="int_area_ex_asu_hydrophobic" equation="Hasu - Hnano" threshold="0">
      		<Var name="Hasu" filter="R_int_area_all_asu_hydrophobic"/>
      		<Var name="Hnano" filter="R_int_area_all_nano_hydrophobic"/>  value="Real"
      	</CalculatorFilter>
      	<Report name="R_int_area_ex_asu_hydrophobic" filter="int_area_ex_asu_hydrophobic"/>
      	<CalculatorFilter name="int_area_ex_asu_polar" equation="Pasu - Pnano" threshold="0">
      		<Var name="Pasu" filter="R_int_area_all_asu_polar"/>
      		<Var name="Pnano" filter="R_int_area_all_nano_polar"/>
      	</CalculatorFilter>
		<Report name="R_int_area_ex_asu_polar" filter="int_area_ex_asu_polar"/>
      	<CalculatorFilter name="int_area_ex_asu_total" equation="H + P" threshold="0">
      		<Var name="H" filter="R_int_area_ex_asu_hydrophobic"/>
      		<Var name="P" filter="R_int_area_ex_asu_polar"/>
      	</CalculatorFilter>
      	<Report name="R_int_area_ex_asu_total" filter="int_area_ex_asu_total"/>
      	# calculate the asu interface area (SASA based)
      	<CalculatorFilter name="int_area_asu_total" equation="H + P" threshold="0">
      		<Var name="H" filter="R_int_area_asu_hydrophobic"/>
      		<Var name="P" filter="R_int_area_asu_polar"/>
      	</CalculatorFilter>
		<Report name="R_int_area_asu_total" filter="int_area_asu_total"/>
		<CalculatorFilter name="int_area_hydrophobic" equation="h_asu + h_ex" threshold="0">
      		<Var name="h_asu" filter="R_int_area_asu_hydrophobic"/>
      		<Var name="h_ex" filter="R_int_area_ex_asu_hydrophobic"/>
      	</CalculatorFilter>
 		<Report name="R_int_area_hydrophobic" filter="int_area_hydrophobic"/>
     	<CalculatorFilter name="int_area_polar" equation="p_asu + p_ex" threshold="0">
      		<Var name="p_asu" filter="R_int_area_asu_polar"/>
      		<Var name="p_ex" filter="R_int_area_ex_asu_polar"/>
      	</CalculatorFilter>
		<Report name="R_int_area_polar" filter="int_area_polar"/>
		<!--       	<CalculatorFilter name="int_area_all_nano_total" equation="H + P" threshold="0">
		      		<Var name="H" filter="R_int_area_all_nano_hydrophobic"/>
		      		<Var name="P" filter="R_int_area_all_nano_polar"/>
		      	</CalculatorFilter>
      			<Report name="R_int_area_all_nano_total" 				filter="int_area_all_nano_total"/> -->
      	# calculate the total interface area (SASA based)
      	<CalculatorFilter name="int_area_total" equation="A + E" threshold="0">
      		<Var name="A" filter="R_int_area_asu_total"/>
      		<Var name="E" filter="R_int_area_ex_asu_total"/>
      	</CalculatorFilter>
		<Report name="R_int_area_total" filter="int_area_total"/>
		# calculate the total number of BUNS
      	<CalculatorFilter name="buns_total" equation="n + nhpol + a + ahpol" threshold="0">
      		<Var name="n" filter="R_buns_nano"/>
      		<Var name="nhpol" filter="R_buns_nano_hpol"/>
      		<Var name="a" filter="R_buns_asu"/>
      		<Var name="ahpol" filter="R_buns_asu_hpol"/>
      	</CalculatorFilter>
		<Report name="R_buns_total" filter="buns_total"/>
	</FILTERS>

	<PROTOCOLS>
		<Add filter_name="time" report_at_end="false"/>
		<Add mover_name="make_lattice"/>
		<Add mover_name="save_nanohedra"/>
		# All between need to be run in the ASU
		<Add mover_name="extract_asu"/>
			<!-- <Add filter_name="asu_int_total" report_at_end="false"/> -->
		<!-- <Add filter_name="R_int_area_asu_hydrophobic"/> -->
		<!-- <Add filter_name="R_int_area_asu_polar"/> -->
		<!-- <Add filter_name="R_buns_asu"/> -->
		<!-- <Add filter_name="R_buns_asu_hpol"/> -->
			<!-- <Add filter_name="asu_res_specific_sasa_total"/> -->
		<Add filter_name="R_rmsd"/>
				<!-- <Add mover_name="interface_analyzer_asu"/> -->
		<Add mover_name="save_asu"/>
		<Add mover_name="translate_asu"/>
		<Add filter_name="R_int_connectivity1"/>
		<Add filter_name="R_int_connectivity2"/>

			<!-- <Add mover_name="dump_pdb_unbound_asu"/> -->
		<Add mover_name="save_asu_unbound"/>
		## Nanohedra analysis ##
		<Add mover_name="restore_nanohedra"/>
				<!-- <Add mover_name="interface_analyzer_nano_fixed_A"/> remove -->
				<!-- <Add mover_name="interface_analyzer_nano_fixed_AB"/> remove -->
				<!-- <Add filter_name="R_interface_analyzer"/> -->
		<Add filter_name="R_full_stability"/>
		<!-- <Add filter_name="R_no_pssm_stability"/> -->
		<!-- <Add filter_name="R_pssm_weight"/> -->
		<!-- <Add filter_name="R_cst_weight"/> -->
		<!-- <Add filter_name="R_int_sc"/> -->
			<!-- <Add filter_name="R_int_connectivity"/> -->
		<!-- <Add filter_name="R_contact_count"/> -->
		<Add mover_name="run_metrics"/>
		<Add mover_name="run_metrics_complex"/>
		<Add mover_name="run_metrics_asu"/>
		<Add mover_name="run_metrics_unbound_asu"/>
				<!-- <Add filter_name="R_energy_per_res"/> -->
				<!-- <Add filter_name="R_hbond_report"/> -->
				<!-- <Add filter_name="R_hbonds_filter"/> -->
		<!-- <Add filter_name="R_int_energy_context"/> -->
		<!-- <Add filter_name="R_buns_nano"/> -->
		<!-- <Add filter_name="R_buns_nano_hpol"/> -->
			<!-- <Add filter_name="R_bsa_total"/> -->
			<!-- <Add filter_name="R_bsa_hydrophobic"/> -->
			<!-- <Add filter_name="R_bsa_polar"/> -->
			<!-- <Add filter_name="R_nano_all_int_sasa_total"/> -->
			<!-- <Add filter_name="R_int_area_all_nano_total"/> -->
		<!-- <Add filter_name="R_int_area_ex_asu_hydrophobic"/> -->
		<!-- <Add filter_name="R_int_area_ex_asu_polar"/> -->
		<!-- <Add filter_name="R_int_area_ex_asu_total"/> -->
		<!-- <Add filter_name="R_int_area_asu_total"/> -->
		<!-- <Add filter_name="R_int_area_total"/> -->
		<!-- <Add filter_name="R_buns_total"/> -->
		
		<Add filter_name="time"/>
	</PROTOCOLS>

</ROSETTASCRIPTS>
