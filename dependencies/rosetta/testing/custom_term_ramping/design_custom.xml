<ROSETTASCRIPTS>

	<SCOREFXNS>
		# patched version of above, reduces weights by 0.5 as the symmetric score function created with MakeLatticeMover and MakeLayerMover arbitrarily doubles monomeric energy
		<ScoreFunction name="2015_nano" weights="ref2015" patch="%%sym_score_patch%%">
			<Reweight scoretype="coordinate_constraint" weight="%%cst_value%%"/>
		</ScoreFunction>
		<ScoreFunction name="2015_nano_1" weights="ref2015" patch="%%scripts%%/ref2015_sym_1.wts_patch">
			<Reweight scoretype="coordinate_constraint" weight="%%cst_value%%"/>
		</ScoreFunction>
		<ScoreFunction name="2015_nano_1min" weights="ref2015" patch="%%scripts%%/ref2015_sym_1min.wts_patch">
			<Reweight scoretype="coordinate_constraint" weight="%%cst_value%%"/>
		</ScoreFunction>
		<ScoreFunction name="2015_nano_2" weights="ref2015" patch="%%scripts%%/ref2015_sym_2.wts_patch">
			<Reweight scoretype="coordinate_constraint" weight="%%cst_value%%"/>
		</ScoreFunction>
		<ScoreFunction name="2015_nano_2min" weights="ref2015" patch="%%scripts%%/ref2015_sym_2min.wts_patch">
			<Reweight scoretype="coordinate_constraint" weight="%%cst_value%%"/>
		</ScoreFunction>
		<ScoreFunction name="2015_nano_3" weights="ref2015" patch="%%scripts%%/ref2015_sym_3.wts_patch">
			<Reweight scoretype="coordinate_constraint" weight="%%cst_value%%"/>
		</ScoreFunction>
		<ScoreFunction name="2015_nano_3min" weights="ref2015" patch="%%scripts%%/ref2015_sym_3min.wts_patch">
			<Reweight scoretype="coordinate_constraint" weight="%%cst_value%%"/>
		</ScoreFunction>
	</SCOREFXNS>

	<RESIDUE_SELECTORS>
		# used for selecting residues on one side of the interface from chain "A". all resnums are listed 23,54,65,90,etc... in the %%interface1%% variable
		<Index name="interface1" resnums="%%interface1%%" error_on_out_of_bounds_index="1" reverse="0"/>
		# same, but for residues from chain "B"
		<Index name="interface2" resnums="%%interface2%%" error_on_out_of_bounds_index="1" reverse="0"/>
		# combined group of all identified interface residues
		<Or name="tot_interface" selectors="interface1,interface2"/>
		# the negation of all interface residues
		<Not name="not_interface" selector="tot_interface"/>
		# select all residues lower than energy 10 invloved in sidechain hydrogen bonding
		<HBond name="hbond_residues" residue_selector="tot_interface" include_bb_bb="false" hbond_energy_cutoff="10" scorefxn="2015_nano"/>
		# all residues
		<True name="full_pose"/>
	</RESIDUE_SELECTORS>

	<TASKOPERATIONS>
		# standard task operation to pull in commandline options
		<InitializeFromCommandline name="init"/>
		# initialize a pose with the input residues
		<IncludeCurrent name="include_current"/>
		# restrict movement of any virtual residues made during symmetry protocol. don't think these are allowed to move unless degrees of freedom are modified, but safe option nonetheless
		<RestrictIdentities name="vrt" identities="XXX" prevent_repacking="1"/>
		# standard operation to restrict all residues to repacking
		<RestrictToRepacking name="rtr"/>
		# make a design restriction at the beggining of design to make all designable interface residues Gly. They will be modified afterwards by other permissable residues
		<DesignRestrictions name="interface_start"> <Action residue_selector="tot_interface" aas="G"/> </DesignRestrictions>
		# disable repacking of the interface only
		<OperateOnResidueSubset name="int_no_repack" selector="tot_interface"> <PreventRepackingRLT/> </OperateOnResidueSubset>
		# restrict the interface to repacking only, no design
		<OperateOnResidueSubset name="int_rtr" selector="tot_interface"> <RestrictToRepackingRLT/> </OperateOnResidueSubset>
		# disable repacking of all non-interface residues
		<OperateOnResidueSubset name="non_int_no_repack" selector="not_interface"> <PreventRepackingRLT/> </OperateOnResidueSubset>
		# restrict all non-interface residues to repacking only, no design
		<OperateOnResidueSubset name="non_int_rtr" selector="not_interface"> <RestrictToRepackingRLT/> </OperateOnResidueSubset>
		# only use residues included in a %%pssm_file%%. options specify how to treat the pssm and which rotamers to include for design
		<SeqprofConsensus name="pssm_cutoff" min_aa_probability="0" convert_scores_to_probabilities="0" probability_larger_than_current="0" keep_native="1"/> filename="%%pssm_file%%" 
		# only use residues around specified resnums for design and repacking. The shell indicates a distance at which the mover searches for resnum neighbors to operate on
		<DesignAround name="des_around_total" design_shell="0.1" resnums="%%interface1%%,%%interface2%%" repack_shell="8.0"/>
	</TASKOPERATIONS>

	<MOVERS>
		# generates symmetry for the system in question using %%sdf%% or %%dist%%
		<SetupForSymmetry name="make_point_group" definition="%%sdf%%" set_global_symmetry_at_parsetime="0"/>
		<MakeLayerMover name="make_layer" contact_dist="%%dist%%"/>
		<MakeLatticeMover name="make_lattice" contact_dist="%%dist%%"/>
		# set all interface residues to GLY, leave everything else untouched
		<SymPackRotamersMover name="start_int" scorefxn="2015_nano" task_operations="init,vrt,include_current,interface_start,non_int_no_repack"/>

		# repack shell around a design residue
		<SymPackRotamersMover name="design_int_1" scorefxn="2015_nano_1" task_operations="init,vrt,include_current,pssm_cutoff,des_around_total"/> 
		<SymPackRotamersMover name="design_int_2" scorefxn="2015_nano_2" task_operations="init,vrt,include_current,pssm_cutoff,des_around_total"/> 
		<SymPackRotamersMover name="design_int_3" scorefxn="2015_nano_3" task_operations="init,vrt,include_current,pssm_cutoff,des_around_total"/> 
		<SymPackRotamersMover name="design_int_4" scorefxn="2015_nano" task_operations="init,vrt,include_current,pssm_cutoff,des_around_total"/>
		# minimize backbones/sc at interface (design), minimize sc elsewhere (packing)
		<TaskAwareSymMinMover name="min_design_int_1" scorefxn="2015_nano_1min" bb="1" chi="1" task_operations="init,vrt,non_int_rtr"/>
		<TaskAwareSymMinMover name="min_design_int_2" scorefxn="2015_nano_2min" bb="1" chi="1" task_operations="init,vrt,non_int_rtr"/>
		<TaskAwareSymMinMover name="min_design_int_3" scorefxn="2015_nano_3min" bb="1" chi="1" task_operations="init,vrt,non_int_rtr"/>
		<TaskAwareSymMinMover name="min_design_int_4" scorefxn="2015_nano" bb="1" chi="1" task_operations="init,vrt,non_int_rtr"/> 
		# sample all rotamers to find minimum
		<SymRotamerTrialsMover name="RTmin" scorefxn="2015_nano" task_operations="init,rtr"/>
		# add coordinateConstraints to restrict design movement during trajectory
		<AddConstraints name="add_csts">
			<CoordinateConstraintGenerator name="coord_cst_gen" residue_selector="full_pose" sd="0.5" bounded="false" sidechain="false" ca_only="false" ambiguous_hnq="false" native="false" align_reference="false"/> # bounded_width="0" no native pose as this isn't refined, sidechain="false" to constrain backbone heavy atoms, could try ca_only as well. bounded="false" makes constraint type harmonic
		</AddConstraints>
		<Subroutine name="metrics_interface_design" xml_fname="%%scripts%%/metrics_scripts/metrics_interface_design.xml"/>
		<SwitchMover name="symmetry_switch" movers="make_point_group,make_layer,make_lattice" selected="%%symmetry%%"/>
		# the main protocol to loop over for interface design
		<ParsedProtocol name="design_block">
			<Add mover_name="design_int_1"/>
			<Add mover_name="min_design_int_1"/>
			<Add mover_name="design_int_2"/>
			<Add mover_name="min_design_int_2"/>
			<Add mover_name="design_int_3"/>
			<Add mover_name="min_design_int_3"/>
			<Add mover_name="design_int_4"/>
			<Add mover_name="min_design_int_4"/>
			<Add mover_name="RTmin"/>
			<Add mover_name="RTmin"/>
		</ParsedProtocol>
		<LoopOver name="design_loop" iterations="4" mover_name="design_block"/>
	</MOVERS>

	<FILTERS>
		<Time name="time"/>
	</FILTERS>

	<PROTOCOLS>
		<Add filter_name="time" report_at_end="false"/>
		<Add mover_name="symmetry_switch"/>
		<Add mover_name="add_csts"/>
		<Add mover_name="start_int"/>
		<Add mover_name="design_loop"/>
		<Add mover_name="metrics_interface_design"/>
		<Add filter_name="time"/>
	</PROTOCOLS>

</ROSETTASCRIPTS>
